import { Connection, PublicKey } from '@solana/web3.js';
import { AnchorProvider, Program, BN, Idl } from '@coral-xyz/anchor';
import { useWallet } from '@solana/wallet-adapter-react';
import { PROGRAM_ID, USDC_MINT } from '../config/blockchain';
import IDL_JSON from './lockin_stake_idl.json';

// Use the imported IDL
const IDL = IDL_JSON as Idl;

// TypeScript interface (keeping for reference, not actively used)
interface LockinStakeIDLType {
  version: string;
  name: string;
  instructions: Array<{
    name: string;
    accounts: Array<{
      name: string;
      isMut: boolean;
      isSigner: boolean;
    }>;
    args: Array<{
      name: string;
      type: string;
    }>;
  }>;
  accounts: Array<{
    name: string;
    type: {
      kind: string;
      fields: Array<{
        name: string;
        type: string | { defined: string };
      }>;
    };
  }>;
  errors: Array<{
    code: number;
    name: string;
    msg: string;
  }>;
}

// The actual IDL is imported from the JSON file above
// OLD manually created IDL has been removed

export const useAnchorProgram = () => {
  const wallet = useWallet();

  const getProgram = (connection: Connection) => {
    if (!wallet) return null;

    // Diagnostic logging
    console.log('[getProgram] env PROGRAM_ID =', process.env.NEXT_PUBLIC_PROGRAM_ID);
    console.log('[getProgram] PROGRAM_ID constant =', PROGRAM_ID.toBase58());
    console.log('[getProgram] wallet = true connected=', wallet.connected);
    console.log('[getProgram] wallet.publicKey =', wallet.publicKey?.toBase58());

    // Validate environment variables
    if (!process.env.NEXT_PUBLIC_PROGRAM_ID && PROGRAM_ID.toBase58() === '11111111111111111111111111111111') {
      throw new Error('PROGRAM_ID missing (NEXT_PUBLIC_PROGRAM_ID not set)');
    }

    const provider = new AnchorProvider(
      connection,
      wallet as any,
      { commitment: 'confirmed' }
    );

    // Validate provider
    console.log('[getProgram] provider.wallet = true pk=', provider?.wallet?.publicKey?.toBase58?.());

    if (!provider?.wallet?.publicKey) {
      throw new Error('Wallet not connected in provider');
    }

    // Note: new Program signature is (IDL, programId, provider) or (IDL, provider)
    // We need to pass programId explicitly for newer Anchor versions
    console.log('[getProgram] About to create Program with:', {
      hasIDL: !!IDL,
      idlName: (IDL as any)?.name,
      idlVersion: (IDL as any)?.version,
      idlAddress: (IDL as any)?.metadata?.address,
      programId: PROGRAM_ID?.toBase58?.(),
      hasProvider: !!provider,
      providerConnection: !!provider?.connection,
    });

    try {
      const program = new Program(IDL, PROGRAM_ID, provider);
      console.log('[getProgram] Program created successfully, programId =', program.programId.toBase58());
      return program;
    } catch (err: any) {
      console.error('[getProgram] Failed to create Program:', err);
      throw new Error(`Failed to create Anchor Program: ${err.message}`);
    }
  };

  return { getProgram };
};

// NOTE: Below this point is where the old manually-created IDL was.
// It has been removed and replaced with the proper IDL import above.

// Helper functions for PDAs
export const getChallengeAddress = async (
    {
      name: "createChallenge",
      accounts: [
        { name: "admin", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "tokenMint", isMut: false, isSigner: false },
        { name: "escrowVault", isMut: true, isSigner: false },
        { name: "systemProgram", isMut: false, isSigner: false },
        { name: "tokenProgram", isMut: false, isSigner: false },
        { name: "associatedTokenProgram", isMut: false, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
        { name: "stakeAmount", type: "u64" },
        { name: "totalDays", type: "u32" },
        { name: "thresholdBps", type: "u16" },
        { name: "platformFeeBps", type: "u16" },
        { name: "startTs", type: "i64" },
        { name: "oracleSigner", type: "publicKey" },
      ],
    },
    {
      name: "joinChallenge",
      accounts: [
        { name: "user", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "participant", isMut: true, isSigner: false },
        { name: "userTokenAccount", isMut: true, isSigner: false },
        { name: "escrowVault", isMut: true, isSigner: false },
        { name: "systemProgram", isMut: false, isSigner: false },
        { name: "tokenProgram", isMut: false, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "recordProof",
      accounts: [
        { name: "oracle", isMut: false, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "participant", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "settleChallenge",
      accounts: [
        { name: "oracle", isMut: false, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "settleParticipant",
      accounts: [
        { name: "oracle", isMut: false, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "participant", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "finalizeSettlement",
      accounts: [
        { name: "oracle", isMut: false, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "claimPayout",
      accounts: [
        { name: "user", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "participant", isMut: true, isSigner: false },
        { name: "userTokenAccount", isMut: true, isSigner: false },
        { name: "escrowVault", isMut: true, isSigner: false },
        { name: "tokenProgram", isMut: false, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "cancelChallenge",
      accounts: [
        { name: "admin", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "claimRefund",
      accounts: [
        { name: "user", isMut: true, isSigner: true },
        { name: "challenge", isMut: false, isSigner: false },
        { name: "participant", isMut: true, isSigner: false },
        { name: "userTokenAccount", isMut: true, isSigner: false },
        { name: "escrowVault", isMut: true, isSigner: false },
        { name: "tokenProgram", isMut: false, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "withdrawFees",
      accounts: [
        { name: "admin", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "adminTokenAccount", isMut: true, isSigner: false },
        { name: "escrowVault", isMut: true, isSigner: false },
        { name: "tokenProgram", isMut: false, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "closeParticipant",
      accounts: [
        { name: "authority", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
        { name: "participant", isMut: true, isSigner: false },
        { name: "destination", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
    {
      name: "closeChallenge",
      accounts: [
        { name: "admin", isMut: true, isSigner: true },
        { name: "challenge", isMut: true, isSigner: false },
      ],
      args: [
        { name: "challengeId", type: "string" },
      ],
    },
  ],
  accounts: [
    {
      name: "Challenge",
      type: {
        kind: "struct",
        fields: [
          { name: "challengeId", type: "string" },
          { name: "admin", type: "publicKey" },
          { name: "tokenMint", type: "publicKey" },
          { name: "escrowVault", type: "publicKey" },
          { name: "stakeAmount", type: "u64" },
          { name: "totalDays", type: "u32" },
          { name: "thresholdBps", type: "u16" },
          { name: "platformFeeBps", type: "u16" },
          { name: "status", type: { defined: "ChallengeStatus" } },
          { name: "startTs", type: "i64" },
          { name: "endTs", type: "i64" },
          { name: "participantCount", type: "u32" },
          { name: "activeParticipants", type: "u32" },
          { name: "winnerCount", type: "u32" },
          { name: "loserCount", type: "u32" },
          { name: "bonusPerWinner", type: "u64" },
          { name: "feeAmount", type: "u64" },
          { name: "remainder", type: "u64" },
          { name: "payoutsClaimedCount", type: "u32" },
          { name: "remainderClaimed", type: "u64" },
          { name: "oracleSigner", type: "publicKey" },
          { name: "bump", type: "u8" },
        ],
      },
    },
    {
      name: "Participant",
      type: {
        kind: "struct",
        fields: [
          { name: "user", type: "publicKey" },
          { name: "challenge", type: "publicKey" },
          { name: "joined", type: "bool" },
          { name: "stakeDeposited", type: "u64" },
          { name: "proofDays", type: "u32" },
          { name: "isWinner", type: "bool" },
          { name: "isSettled", type: "bool" },
          { name: "payoutClaimed", type: "bool" },
          { name: "refundClaimed", type: "bool" },
          { name: "bump", type: "u8" },
        ],
      },
    },
  ],
  errors: [
    { code: 6000, name: "InvalidAmount", msg: "Invalid amount" },
    { code: 6001, name: "InvalidDuration", msg: "Invalid duration" },
    { code: 6002, name: "InvalidThreshold", msg: "Invalid threshold" },
    { code: 6003, name: "InvalidFee", msg: "Invalid fee" },
    { code: 6004, name: "InvalidStartTime", msg: "Invalid start time" },
    { code: 6005, name: "InvalidChallengeStatus", msg: "Invalid challenge status" },
    { code: 6006, name: "ChallengeStarted", msg: "Challenge already started" },
    { code: 6007, name: "ChallengeNotStarted", msg: "Challenge not started yet" },
    { code: 6008, name: "ChallengeEnded", msg: "Challenge has ended" },
    { code: 6009, name: "NotJoined", msg: "User not joined" },
    { code: 6010, name: "InvalidOracle", msg: "Invalid oracle" },
  ],
};

export const useAnchorProgram = () => {
  const wallet = useWallet();
  
  const getProgram = (connection: Connection) => {
    if (!wallet) return null;

    // Diagnostic logging
    console.log('[getProgram] env PROGRAM_ID =', process.env.NEXT_PUBLIC_PROGRAM_ID);
    console.log('[getProgram] PROGRAM_ID constant =', PROGRAM_ID.toBase58());
    console.log('[getProgram] wallet =', !!wallet, 'connected=', wallet.connected);
    console.log('[getProgram] wallet.publicKey =', wallet.publicKey?.toBase58());

    // Validate environment variables
    if (!process.env.NEXT_PUBLIC_PROGRAM_ID && PROGRAM_ID.toBase58() === '11111111111111111111111111111111') {
      throw new Error('PROGRAM_ID missing (NEXT_PUBLIC_PROGRAM_ID not set)');
    }

    const provider = new AnchorProvider(
      connection,
      wallet as any,
      { commitment: 'confirmed' }
    );

    // Validate provider
    console.log('[getProgram] provider.wallet =', !!provider?.wallet, 'pk=', provider?.wallet?.publicKey?.toBase58?.());

    if (!provider?.wallet?.publicKey) {
      throw new Error('Wallet not connected in provider');
    }

    // Note: new Program signature is (IDL, programId, provider) or (IDL, provider)
    // We need to pass programId explicitly for newer Anchor versions
    console.log('[getProgram] About to create Program with:', {
      hasIDL: !!IDL,
      idlName: IDL?.name,
      idlVersion: IDL?.version,
      programId: PROGRAM_ID?.toBase58?.(),
      hasProvider: !!provider,
      providerConnection: !!provider?.connection,
    });

    try {
      const program = new Program(IDL as any, PROGRAM_ID, provider);
      console.log('[getProgram] Program created successfully, programId =', program.programId.toBase58());
      return program;
    } catch (err: any) {
      console.error('[getProgram] Failed to create Program:', err);
      throw new Error(`Failed to create Anchor Program: ${err.message}`);
    }
  };

  return { getProgram };
};

// Helper functions for PDAs
export const getChallengeAddress = async (
  challengeId: string,
  admin: PublicKey
): Promise<[PublicKey, number]> => {
  return PublicKey.findProgramAddressSync(
    [
      Buffer.from('challenge'),
      Buffer.from(challengeId),
      admin.toBuffer()
    ],
    PROGRAM_ID
  );
};

export const getParticipantAddress = async (
  challengePDA: PublicKey,
  user: PublicKey
): Promise<[PublicKey, number]> => {
  return PublicKey.findProgramAddressSync(
    [
      Buffer.from('participant'),
      challengePDA.toBuffer(),
      user.toBuffer()
    ],
    PROGRAM_ID
  );
};

// Challenge creation parameters
export interface CreateChallengeParams {
  challengeId: string; // Unique challenge identifier
  stakeAmount: number; // SOL amount (will be converted to lamports)
  totalDays: number;
  thresholdBps: number; // Basis points (e.g., 8000 = 80%)
  platformFeeBps: number; // Basis points (e.g., 500 = 5%)
  startDate: Date;
  oraclePublicKey: PublicKey;
}

export interface JoinChallengeParams {
  challengeId: string; // Challenge ID string
  challengePDA: PublicKey; // Challenge PDA address
}